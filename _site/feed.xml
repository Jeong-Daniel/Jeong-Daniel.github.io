<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-07-07T14:07:14+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Backend Developer’s Room</title><subtitle>[&quot;Welcome to the Backend Developer&apos;s Room. I am posting blogs to deal with technical theories and field applications.&quot;]</subtitle><entry><title type="html">DAO, DTO 그리고 Entity Class</title><link href="http://localhost:4000/db/2022/07/03/DAO,-DTO-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Entity-Class.html" rel="alternate" type="text/html" title="DAO, DTO 그리고 Entity Class" /><published>2022-07-03T09:38:46+09:00</published><updated>2022-07-03T09:38:46+09:00</updated><id>http://localhost:4000/db/2022/07/03/DAO,%20DTO%20%EA%B7%B8%EB%A6%AC%EA%B3%A0%20Entity%20Class</id><content type="html" xml:base="http://localhost:4000/db/2022/07/03/DAO,-DTO-%EA%B7%B8%EB%A6%AC%EA%B3%A0-Entity-Class.html"><![CDATA[<p>JAVA에서 데이터를 핸들링하기 위한 방법을 먼저 정리할려고 했으나 먼저 객체가 어떻게 DB에 접근하는가를 정리하는게 맞겠다고 생각했습니다. 특히 Spring을 사용하다보면 공식문서를 비롯해서 DAO, DTO, Entity Class등의 개념이 나오게 되는데 해당 개념에 대해 정리를 해두면 좋을 듯 합니다.</p>

<h2 id="1-daodata-access-object">1. DAO(Data Access Object)</h2>
<p>DAO는 데이터베이스의 Data에 접근하기 위한 객체입니다. 데이터만 담당하는 클래스로 DB의 CRUD 기능을 수행합니다. 우리가 필요한 객체를 바로 DB에 연결하지 않는 이유는 크게 두가지인데 DB 접근 로직과 비즈니스 로직의 분리를 위함이며 나중에 DB가 변경되더라도 DB 접근로직만 변경하면 되기에 비즈니스 로직을 건드리지 않아도 됩니다. 주로 DAO로 뭉떵거리기 보다 DAOInterface/DAOImplement 로 구분지어 명세와 구현 분리하며 개발합니다.</p>

<p><img src="\assets\img\DAO.png" alt="DAO image" /></p>

<p>요약</p>
<ul>
  <li>실제로 DB에 접근하는 객체로 Persistence Layer(DB에 data를 CRUD하는 계층)</li>
  <li>Service와 DB를 연결하는 고리</li>
  <li>SQL을 사용하여 DB에 접근한 다음 적절한 CRUD API를 제공</li>
</ul>

<p>*JPA의 Repository package사용을 통한 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">interface</span> <span class="nc">QuestionRepository</span> <span class="kd">extends</span> <span class="nc">CrudRepository</span><span class="o">&lt;</span><span class="nc">Question</span><span class="o">,</span> <span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
<span class="o">}</span>
</code></pre></div></div>
<p>문제는 여기서 개념이 한번더 나누어지게 되는데 Repository와 DAO의 차이다. 결론부터 말하면 DAO는 Data Peristence의 추상화이고, Repository는 객체 Collection의 추상화다. 데이터를 접근한다는 점에서 공통점을 가지고 있지만 Repository는 객체 중심, DAO는 데이터 저장소(DB 테이블)중심이 된다.</p>

<h2 id="2-dtodata-transfer-object">2. DTO(Data Transfer Object)</h2>
<p>DTO는 계층간 데이터 교환을 위한 객체(Java Beans)입니다. Controller, Service, View 처럼 계층 간의 데이터 교환을 위해 사용합니다. 이 객체는 로직을 갖고 있지 않으며 순수한 데이터 객체이며 getter, setter 메소드만을 갖고 있습니다. 많은 경우 DB에서 꺼낸 값을 전달하는 것이 목적이지 변경할 이유는 없기에 DTO 클래스에는 setter이 없을 수도 있습니다.</p>

<p><img src="\assets\img\data_tier.jpg" alt="DAO image" /></p>

<p>즉 DB의 데이터가 Presentation Logic Tier로 넘어오게 될 때는 DTO의 모습으로 전달합니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@NoArgsConstructor</span>
<span class="nd">@AllArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">UserDto</span> <span class="o">{</span>
  <span class="nd">@NotBlank</span>
  <span class="nd">@Pattern</span><span class="o">(</span><span class="n">regexp</span> <span class="o">=</span> <span class="s">"^([\\w-]+(?:\\.[\\w-]+)*)@((?:[\\w-]+\\.)*\\w[\\w-]{0,66})\\.([a-z]{2,6}(?:\\.[a-z]{2})?)$"</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>

  <span class="nd">@JsonIgnore</span>
  <span class="nd">@NotBlank</span>
  <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">4</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">15</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">password</span><span class="o">;</span>

  <span class="nd">@NotBlank</span>
  <span class="nd">@Size</span><span class="o">(</span><span class="n">min</span> <span class="o">=</span> <span class="mi">6</span><span class="o">,</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">10</span><span class="o">)</span>
  <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nc">User</span> <span class="nf">toEntity</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">User</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">password</span><span class="o">,</span> <span class="n">name</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nc">User</span> <span class="nf">toEntityWithPasswordEncode</span><span class="o">(</span><span class="nc">PasswordEncoder</span> <span class="n">bCryptPasswordEncoder</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="k">new</span> <span class="nf">User</span><span class="o">(</span><span class="n">email</span><span class="o">,</span> <span class="n">bCryptPasswordEncoder</span><span class="o">.</span><span class="na">encode</span><span class="o">(</span><span class="n">password</span><span class="o">),</span> <span class="n">name</span><span class="o">);</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>
<p>toEntity() 메서드를 통해서 DTO에서 필요한 부분을 이용하여 Entity로 만든 코드</p>
<ul>
  <li>Request와 Response용 DTO는 View를 위한 클래스</li>
</ul>

<h3 id="추가-정리-vovalue-object와-bobusiness-object">추가 정리 VO(Value Object)와 BO(Business Object)</h3>
<ul>
  <li>
    <p>VO는 DTO와 유사하게 보이고 read only 속성을 갖는다. 하지만 개념이 다르다.
VO는 특정한 비즈니스 값을 담는 객체이고, DTO는 Layer간의 통신 용도로 오고가는 객체를 말한다. VO는 값들에 대해 Read-Only를 보장해줘야 존재의 신뢰성이 확보되지만 DTO의 경우는 단지 데이터를 담는 그릇의 역할일 뿐 값은 그저 전달되어야 할 대상일 뿐이다. 값 자체에 의미가 있는 VO와 전달될 데이터를 보존해야하는 DTO의 특성상 개념이 다르다.</p>
  </li>
  <li>
    <p>BO는 VO와 마찬가지로 데이터 저장 담당 클래스이나 이름처럼 비즈니스 로직을 담고 있는 객체, 즉 비즈니스 관련 내용을 담은 VO가 BO</p>
  </li>
</ul>

<p><img src="\assets\img\DTO.png" alt="DAO image" /></p>

<p>유저가 입력한 데이터를 DB에 넣는 과정은 웹앱 기준으로 브라우저에서 데이터를 입력하여 form에 있는 데이터를 DTO에 넣어서 전송
그리고 DTO를 받은 서버가 DAO를 이용하여 DB로 데이터를 저장</p>

<h2 id="3-entity-class">3. Entity Class</h2>
<p>실제 DB의 테이블과 매칭될 클래스다. DB 테이블에 존재하는 Column들을 필드로 가지는 객체를 말한다. 가장 Core한 클래스라고 부르기도하며 JPA에서 @Entity 어노테이션을 붙여서 Entity클래스임을 명시해야하고 내부 필드에는 @Column, @Id 어노테이션을 이용한다. DB 테이블과 1:1 대응관계에 있기 때문에 테이블이 가지지 않는 컬럼을 필드로 가지면 안되며 Entity클래스는 다른 클래스를 상속받거나 인터페이스의 구현체가 되서는 안된다. 그래서 외부에서 Entity 클래스의 getter method를 사용하지 않도록 해당 클래스 안에서 필요한 로직 method을 구현한다. 다시 말해 Domain 로직만 구현하고 Presentation 로직은 구현하지 않는다.</p>

<p>Entity 클래스에서 Setter를 만드는 것은 피하길 권장한다. Setter가 모든 클래스에 있거나 너무 많을 경우 인스턴스 값들이 어느 지점에서 변경이 이루어지는지 명확하게 알 수 없기에 다른 방법으로 필드에 값을 채우는 것이 좋다. 하지만 생성 시점에 생성자로 필드에 값을 넣어주는 방법 또한 그다지 좋지 않은 방법일 수 있다. 생성자에 현재 넣는 값이 어떤 필드인지 명확히 알 수 없고, 매개변수끼리의 순서가 바뀌더라도 코드가 모두 실행되기 전까지는 문제를 알 수 없다는 단점이 있기 때문이다.</p>

<p>아래 예시는 Builder 패턴을 사용하는데 멤버 변수가 많아지더라도 어떤 값을 어떤 필드에 넣는지 코드를 통해 확인할 수 있고, 필요한 값만 집어넣는 것이 가능하기 때문</p>

<p><img src="\assets\img\Entity.png" alt="DAO image" /></p>

<p>Entity Class와 DTO를 분리하는 이유는 View Layer와 DB Layer의 역할을 철저하게 분리하기 위함입니다. Entity Class는 기획단계에서 결정되기 때문에 한번 확정이 되면 변경하는 것이 어려워 여러 클래스에 영향을 끼치게 되는 반면 View와 통신하는 DTO 클래스(Request / Response 클래스)는 자주 변경되므로 분리해야 한다.</p>

<p>Entity 클래스 생성 및 Builder 패턴 예시</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Getter</span>
<span class="nd">@Entity</span>
<span class="nd">@NoArgsConstructor</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">Membmer</span> <span class="n">member</span> <span class="o">{</span>
    <span class="nd">@Id</span>
    <span class="nd">@GeneratedValue</span><span class="o">(</span><span class="n">strategy</span> <span class="o">=</span> <span class="nc">GenerationType</span><span class="o">.</span><span class="na">IDENTITY</span><span class="o">)</span>
    <span class="kd">private</span> <span class="kt">long</span> <span class="n">id</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">name</span><span class="o">;</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">email</span><span class="o">;</span>
    <span class="nd">@Column</span><span class="o">(</span><span class="n">length</span> <span class="o">=</span> <span class="mi">13</span><span class="o">,</span> <span class="n">nullable</span> <span class="o">=</span> <span class="kc">false</span><span class="o">)</span>
    <span class="kd">private</span> <span class="nc">String</span> <span class="n">phoneNumber</span><span class="o">;</span>
 
    <span class="nd">@Builder</span>
    <span class="kd">public</span> <span class="nf">Member</span><span class="o">(</span><span class="kt">long</span> <span class="n">id</span><span class="o">,</span> <span class="nc">String</span> <span class="n">name</span><span class="o">,</span> <span class="nc">String</span> <span class="n">email</span><span class="o">,</span> <span class="nc">String</span> <span class="n">phoneNumber</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">id</span> <span class="o">=</span> <span class="n">id</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">name</span> <span class="o">=</span> <span class="n">name</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">email</span> <span class="o">=</span> <span class="n">email</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">phoneNumber</span> <span class="o">=</span> <span class="n">phoneNumber</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="c1">// 사용 방법</span>
<span class="nc">Member</span> <span class="n">member</span> <span class="o">=</span> <span class="k">new</span> <span class="n">member</span><span class="o">.</span><span class="na">builder</span><span class="o">()</span>
        <span class="o">.</span><span class="na">name</span><span class="o">(</span><span class="s">"홍길동"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">email</span><span class="o">(</span><span class="s">"test@gmail.com"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">phoneNumber</span><span class="o">(</span><span class="s">"010-1234-5678"</span><span class="o">)</span>
        <span class="o">.</span><span class="na">build</span><span class="o">();</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="DB" /><category term="java," /><category term="db," /><category term="spring," /><category term="jpa," /><category term="DAO," /><category term="DTO" /><summary type="html"><![CDATA[JAVA에서 데이터를 핸들링하기 위한 방법을 먼저 정리할려고 했으나 먼저 객체가 어떻게 DB에 접근하는가를 정리하는게 맞겠다고 생각했습니다. 특히 Spring을 사용하다보면 공식문서를 비롯해서 DAO, DTO, Entity Class등의 개념이 나오게 되는데 해당 개념에 대해 정리를 해두면 좋을 듯 합니다.]]></summary></entry><entry><title type="html">JAVA에서 DB를 핸들링하는 3가지 방법</title><link href="http://localhost:4000/java/2022/06/29/JAVA%EC%97%90%EC%84%9C-DB%EB%A5%BC-%ED%95%B8%EB%93%A4%EB%A7%81%ED%95%98%EB%8A%94-3%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95.html" rel="alternate" type="text/html" title="JAVA에서 DB를 핸들링하는 3가지 방법" /><published>2022-06-29T09:38:46+09:00</published><updated>2022-06-29T09:38:46+09:00</updated><id>http://localhost:4000/java/2022/06/29/JAVA%EC%97%90%EC%84%9C%20DB%EB%A5%BC%20%ED%95%B8%EB%93%A4%EB%A7%81%ED%95%98%EB%8A%94%203%EA%B0%80%EC%A7%80%20%EB%B0%A9%EB%B2%95</id><content type="html" xml:base="http://localhost:4000/java/2022/06/29/JAVA%EC%97%90%EC%84%9C-DB%EB%A5%BC-%ED%95%B8%EB%93%A4%EB%A7%81%ED%95%98%EB%8A%94-3%EA%B0%80%EC%A7%80-%EB%B0%A9%EB%B2%95.html"><![CDATA[<p>제목 그대로 자바에서 DB를 핸들링하는 방법을 정리하고자 합니다. 대표적인 방법 3가지로 자바에 내장된 JDBC, Spring JDBC 마지막으로 JPA가 있으며 각각의 특징과 코드를 설명하고자 합니다.</p>

<h2 id="1-jdbcjava-database-connectivity">1. JDBC(Java Database Connectivity)</h2>
<p>JDBC는 자바에서 데이터베이스에 접속할 수 있도록 하는 자바 API입니다. JDBC를 통해서 데이터베이스에서 쿼리를 보내거나 데이터를 조작할 수 있는 방법을 제공합니다.</p>

<p>JDBC는 JDK(Java Development Kit)에 내장되어 있으며 자바 패키지 java.sql과 javax.sql에 포함되어 있습니다.</p>

<p><img src="\assets\img\JDBC.png" alt="JDBC 드라이버" /></p>

<p>JDBC의 특징은 DBMS에 종속되지 않는 드라이버를 제공합니다. JDBC API에서 바로 DB로 접근하는 것이 아닌 각 DB에 맞는 드라이버 매니저를 제공하는데 이는 유지 보수에 있어 나중에 DB가 변경되더라도 드라이버 매니저만 교체하면 됩니다.</p>

<p><img src="\assets\img\JDBCconnection.png" alt="Data Access Layer" /></p>

<p>데이터베이스 연동과정은 JDBC드라이버를 Load하고 Connection 객체를 생성하고, Statement 객체를 생성한다음 Query를 수행하는 방법으로 진행됩니다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Class</span><span class="o">.</span><span class="na">forName</span><span class="o">(</span><span class="s">"com.mysql.Jdbc.Driver"</span><span class="o">);</span>
</code></pre></div></div>
<p>Class.forName() 메서드를 호출하여, mysql에서 제공하는 Driver 클래스를 JVM method area에 로딩</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">jdbc_url</span> <span class="o">=</span> <span class="s">"jdbc:mysql://localhost:3306/datebase?serverTimezone=UTC"</span><span class="o">;</span>
<span class="nc">Connection</span> <span class="n">con</span> <span class="o">=</span> <span class="nc">DriverManager</span><span class="o">.</span><span class="na">getConnection</span><span class="o">(</span><span class="no">URL</span><span class="o">,</span> <span class="s">"user"</span><span class="o">,</span> <span class="s">"password"</span><span class="o">);</span>
</code></pre></div></div>
<p>(로컬 환경에서 MySQL의 포트번호가 3306)
Connection 객체를 생성한다음 getConnection() 메서드를 호출해서 DB 접속을 위한 정보를 입력</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Statement</span> <span class="n">stmt</span> <span class="o">=</span> <span class="n">con</span><span class="o">.</span><span class="na">createStatement</span><span class="o">();</span> 
</code></pre></div></div>
<p>객체 생성</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">sql</span> <span class="o">=</span> <span class="s">"select * from student"</span><span class="o">;</span>
<span class="nc">ResultSet</span> <span class="n">result</span> <span class="o">=</span> <span class="n">stmt</span><span class="o">.</span><span class="na">executeQuery</span><span class="o">(</span><span class="n">sql</span><span class="o">);</span>  
</code></pre></div></div>
<p>쿼리 생성과 select 문장을 실행하기 위해서 Statement의 메소드 executeQuery()를 사용합니다 이외에도 업데이트를 하고 싶다면 executeUpdate(), create, drop, insert, delete 등을 사용해 테이블의 내용을 조작할 수 있습니다.</p>

<p>그리고 인터페이스 ResultSet로 반환형을 받습니다.</p>

<h2 id="2-spring-jdbc">2. Spring JDBC</h2>
<p>JDBC가 JDK에 내장되었다면 Spring JDBC는 JDBC의 모든 저수준 처리를 스프링 프레임워크에 위임해서 Connection 연결 객체 생성 및 종료, Statement 준비/실행 및 종료, ResultSet 처리 및 종료, 예외 처리, 트랙잭션 등의 반복되는 처리를 개발자가 직접하지 않고 Database에 대한 작업을 수행할 수 있습니다.</p>

<h2 id="3-jpa">3. JPA</h2>]]></content><author><name></name></author><category term="JAVA" /><category term="java," /><category term="db," /><category term="spring," /><category term="jpa" /><summary type="html"><![CDATA[제목 그대로 자바에서 DB를 핸들링하는 방법을 정리하고자 합니다. 대표적인 방법 3가지로 자바에 내장된 JDBC, Spring JDBC 마지막으로 JPA가 있으며 각각의 특징과 코드를 설명하고자 합니다.]]></summary></entry><entry><title type="html">데이터와 모델의 편향(bias)과 분산(variance)</title><link href="http://localhost:4000/machine/learning/2021/12/28/%ED%8E%B8%ED%96%A5(bias)%EA%B3%BC-%EB%B6%84%EC%82%B0(variance).html" rel="alternate" type="text/html" title="데이터와 모델의 편향(bias)과 분산(variance)" /><published>2021-12-28T00:38:46+09:00</published><updated>2021-12-28T00:38:46+09:00</updated><id>http://localhost:4000/machine/learning/2021/12/28/%ED%8E%B8%ED%96%A5(bias)%EA%B3%BC%20%EB%B6%84%EC%82%B0(variance)</id><content type="html" xml:base="http://localhost:4000/machine/learning/2021/12/28/%ED%8E%B8%ED%96%A5(bias)%EA%B3%BC-%EB%B6%84%EC%82%B0(variance).html"><![CDATA[<p><strong><a href="https://en.wikipedia.org/wiki/Bias%E2%80%93variance_tradeoff">편향과 분산의 트레이드오프 위키 URL</a></strong> 데이터 과학을 공부하고 기계학습(Machine Learning)을 다루다보면 한번쯤은 편향(bias)과 분산(variance에 대해서 만나게 됩니다. 제가 컴퓨터공학과에서 들었던 인공지능 수업에서도 교수님께서 설명을 하실때 가끔 데이터와 모델의 편향과 분산을 섞어 말하시고 나중에 정정하는 것을 보면서 이참에 정리를 해보고자 합니다.</p>

<h2 id="1-편향bias">1. 편향(bias)</h2>
<p><strong>데이터</strong>의 편향은 얼마나 데이터가 골고루 분포하는가 입니다. 예를 들어서 이상탐지등의 경우 전체 데이터에서 이상치의 비중은 매우 낮으며 이런 데이터를 가지고 그대로 학습을 할 경우 모델의 정확도를 담보할 수 없습니다. 이때 언더/오버샘플링 등을 통해서 보정을 합니다.</p>

<p><strong>머신러닝</strong>의 편향은 예측값과 실제값 간의 차이를 뜻합니다. 모델 학습시 여러 데이터를 사용하고 반복해서 새로운 모델로 학습하면 예측값들의 범위를 확인할 수 있고 편향은 이 예측값 들의 범위가 정답과 얼마나 멀리 있는지 측정합니다.</p>

<h2 id="2-분산varience">2. 분산(Varience)</h2>
<p><strong>데이터</strong>의 분산은 중심을 측정한뒤 샘플 데이터와 모집단의 데이터가 중심으로 부터 얼마나 분산되어 있는지 확인합니다. 이때 측정하는 방법은 여러가지가 있으며 분산은 편차제곱을 모두 더한뒤 편차 제곱의 평균을 구한 것입니다. 분산 값이 클 수록 데이터가 중심으로부터 떨어졌다는 의미</p>

<p><strong>머신러닝</strong>의 분산은 데이터로 학습한 모델이 예측한 값의 변동성을 뜻하며 만약 여러 모델로 학습을 반복한다고 가정하면 분산은 학습된 모델별로 예측한 값들의 차이를 측정</p>]]></content><author><name></name></author><category term="Machine" /><category term="Learning" /><category term="math," /><category term="ML" /><summary type="html"><![CDATA[편향과 분산의 트레이드오프 위키 URL 데이터 과학을 공부하고 기계학습(Machine Learning)을 다루다보면 한번쯤은 편향(bias)과 분산(variance에 대해서 만나게 됩니다. 제가 컴퓨터공학과에서 들었던 인공지능 수업에서도 교수님께서 설명을 하실때 가끔 데이터와 모델의 편향과 분산을 섞어 말하시고 나중에 정정하는 것을 보면서 이참에 정리를 해보고자 합니다.]]></summary></entry></feed>